drop table if exists timutimu;
create table timutimu(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255),
                            'Search_Algorithm' int(1),
                            'sorting_algorithm' int(1),
                            'Link_List' int(1),
                            'queue' int(1),
                            'stack' int(1),
                            'array' int(1),
                            'tree' int(1),
                            'graph' int(1));
insert into timutimu(content,option_A,option_B,option_C,option_D,correct_ot,explanation,
            Search_Algorithm,sorting_algorithm,Link_List,queue,stack,array,tree,graph) values
            ('对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是()',
            'A. head==NULL',
            'B. head.next==NULL',
            'C. head.next==head',
            'D. head!=NULL',2,
            'B. head.next==NULL是判定该带头结点的单链表为空表的条件，因为在带头结点的单链表中，head指向的是头结点，而头结点的next指针一个元素结点，如果表中没有元素结点，那么头结点的next指针就应该为NULL',
            0,0,1,0,0,0,0,0),

            ('在双向循环链表中,在p指针所指向的结点前插入一个指针q所指向的新结点,其修改指针的操作是( )',
            'A. p.llink=q； q.rlink=p； p.llink.rlink=q； q.llink=q',
            'B. p.llink=q； p.llink.rlink=q； q.rlink= p； q.llink=p.llink',
            'C. q.rlink=p； q.llink=p.llink； p.llink.rlink=q；  p.llink=q',
            'D. q.llink=p.llink；q.rlink:=p； p.llink=q； p↑.llink=q',3,
            '选项C是正确的操作顺序。其他选项中，有些是缺少指针修改，有些则是指针修改顺序错误',
            0,0,1,0,0,0,0,0),

            ('一个栈的输入序列为1、2、3、4、5，则下列序列中不可能是栈的输出序列的是',
            'A. 2、3、4、1、5',
            'B. 5、4、2、3、1',
            'C. 2、3、1、4、5',
            'D. 1、5、4、3、2',2,
            '选项B中的输出序列得到的逆序输入序列为5、4、2、3、1，与原输入序列不一致。因此，选项B中的序列不可能是栈的输出序列。',
            0,0,0,0,1,0,0,0),

            ('循环队列A[0..m-1]存放其元素值，用front和rear分别表示队头和队尾，则当前队列中的元素数是( )',
            'A. (rear-front+m)%m',
            'B. rear-front+1',
            'C. rear-front-1',
            'D. rear-front',1,
            '在循环队列中，队尾指针rear始终指向队列中最后一个元素的下一个位置，队头指针front指向队列中第一个元素的位置。一种常用的计算公式是：(rear-front+m)%m，其中m为队列的最大长度，%为取模运算符。',
            0,0,0,1,1,0,0,0),

            ('设二维数组a[1..5][1..8]，若按列优先的顺序存放数组的元素，则a[4][6]元素的前面（ ）个元素。',
            'A. 6',
            'B. 28',
            'C. 29',
            'D. 40',3,
            '要求a[4][6]元素前面的元素个数，可以计算它在一维数组中的下标，即(6-1)*5+4=29。',
            0,0,0,0,0,1,0,0),

            ('设栈S和队列Q的初始状态为空，元素e1，e2，e3，e4,e5和e6依次通过栈S，一个元素出栈后即进队列Q，若6个元素出队的序列是e2，e4，e3,e6,e5,e1则栈S的容量至少应该是( )。',
            'A. 6',
            'B. 4',
            'C. 3',
            'D. 2',4,
            '根据进栈的顺序，可以得到栈S的初始状态为e1，e2，e3，e4，e5，e6。根据栈的特性，先进后出，因此最后出栈的是e2，因此栈的容量至少应该是2，因此答案为D. 2。',
            0,0,0,1,0,0,0,0),

            ('若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为多少？( )',
            'A. 1和 5',
            'B. 2和4',
            'C. 4和2',
            'D. 5和1',2,
            '由于数组的大小为6，当rear指向数组的最后一个元素时，需要将其指向数组的第一个元素，因此rear的最终值为2%6=2。因此，删除一个元素并加入两个元素后，rear和front的值分别为2和4。',
            0,0,1,0,0,0,0,0),

            ('高度为h（h>0）的满二叉树对应的森林由（ ） 棵树构成',
            'A. 1',
            'B. log2h',
            'C. h/2',
            'D. h',4,
            '高度为h的满二叉树中，所有叶子结点的层次均为h，其根结点及其左下结点共有h个，所以还原成森林含有h棵树',
            0,0,0,0,0,0,1,0),

            ('设有一棵哈夫曼树的结点总数为35，则该哈夫曼树共有 （ ）个叶子结点',
            'A. 18',
            'B. 20',
            'C. 35',
            'D. 30',1,
            '2n-1 = 35, n=18',
            0,0,0,0,0,0,1,0),

            ('一棵具有 n个结点的完全二叉树的树高度（深度）是（ ）',
            'A. |logn|+1',
            'B. logn+1',
            'C. |logn|',
            'D. logn-1',1,
            '对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同,且叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树的左部。深度为k的完全二叉树在k-1层上一定是满二叉树。即答案为A。',
            0,0,0,0,0,0,1,0),

            ('二叉树的先序遍历和中序遍历如下： 先序遍历：EFHIGJK；中序遍历: HFIEJKG 。该二叉树根的右子树的根是：',
            'E',
            'F',
            'G',
            'H',3,
            '由于先序遍历序列的第一个元素是根节点，因此，该二叉树的根节点是E。需要找到E的右子树的根节点。根据中序遍历序列，E的左边是HF，右边是IJKG，因此E的右子树的根节点一定在先序遍历序列EFHIGJK的HIGJK中。H是E的左孩子，因此H不可能是E的右子树的根节点。因此，需要继续查找。在剩余的IJKG中，I是H的右兄弟，因此I也不可能是E的右子树的根节点。在剩余的JKG中，K是I的左孩子，因此K也不可能是E的右子树的根节点。G是K的右兄弟，因此G可能是E的右子树的根节点。如果G是E的右子树的根节点，则E的右子树的先序遍历序列为GHJK，中序遍历序列为JKG。根据这两个序列，可以构造出E的右子树，得到答案为C。',
            0,0,0,0,0,0,1,0),

            ('某二叉树中序序列为A,B,C,D,E,F,G，后序序列为B,D,C,A,F,G,E 则前序序列是：',
            'E,G,F,A,C,D,B',
            'E,A,C,B,D,G,F',
            'E,A,G,C,F,B,D',
            '上面的都不对',4,
            '从后序序列中可以得到根节点为E。然后，在中序序列中找到根节点E的位置，将中序序列分为左子树A,B,C,D和右子树F,G，同时可以得到后序序列中左子树的序列为B,D,C，右子树的序列为F,G。对于左子树，它的根节点为B，可以通过后序序列得到它的左子树为D，右子树为C，因此，左子树的前序序列为B,D,C。对于右子树，它的根节点为F，可以通过后序序列得到它的左子树为G，右子树为空，因此，右子树的前序序列为F,G。综上所述，该二叉树的前序序列为E,B,D,C,F,G,A。',
            0,0,0,0,0,0,1,0),

            ('设有向图n个顶点和e条边，进行拓补排序时，总的计算时间为',
            'A. O<nlog(2)e>',
            'B. O<e*n>',
            'C. O<elog(2)n>',
            'D. O<n+e>',4,
            '拓补排序：对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序的序列，简称拓扑序列。',
            1,1,0,0,0,0,0,1),

            ('关键路径是事件结点网络中',
            'A. 从源点到汇点的最长路径',
            'B. 从源点到汇点的最短路径',
            'C. 最长的回路',
            'D. 最短的回路',1,
            '关键路径是是从源点到汇点的最长路径的长度。',
            1,0,0,0,0,0,0,1),

            ('有10个结点的无向图至少有（）条边才能确保其是连通图',
            'A. 8',
            'B. 9',
            'C. 10',
            'D. 11',2,
            '在一个无向图G中，若从顶点vi到顶点vj有路径相连(当然从vj到vi也一定有路径)，则称vi和vj是连通的。如果G是有向图，那么连接vi和vj的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。',
            1,0,0,0,0,0,0,1),

            ('最短路径的生成算法可用',
            'A. 普利姆算法',
            'B. 克鲁斯卡尔算法',
            'C. 迪杰斯特拉算法',
            'D. 哈夫曼算法',3,
            '迪杰斯特拉算法基本原理：从起始点出发，重复寻找当前距离起始点最近的且未访问过的结点，然后利用该结点更新距离数组，直到访问过全部结点为止，最终的距离数组即为起始点到其余各点的最短路径距离。',
            1,0,0,0,0,0,0,1),

            ('n条边的无向图的邻接表的存储中，边结点的个数有',
            'A. n',
            'B. 2n',
            'C. n/2',
            'D. n*n',1,
            'n条边->n个结点。',
            1,0,0,0,0,0,0,1),

            ('下列哪一种图的邻接矩阵是对称矩阵',
            'A. 有向图',
            'B. 无向图',
            'C. AOV网',
            'D. AOE网',2,
            '只有无向图的邻接矩阵是对称矩阵。',
            1,0,0,0,0,0,0,1),

            ('如果一个表既能较快地查找，又能适应动态变化的要求，则可采用( ) 。',
            'A. 有序表',
            'B. 线性表',
            'C. 哈希表',
            'D. 二叉平衡树',4,
            '在二叉平衡树中进行插入或删除操作时，会通过旋转操作来调整树的结构，以使得树的左右子树的高度差不超过1。这样可以保证树的高度始终保持在一个较小的范围内，从而保证了查找、插入和删除操作的时间复杂度都能够达到O(log n)的水平。此外，二叉平衡树还能够适应动态变化的要求，因为它可以通过旋转操作来动态调整树的结构，以适应不断变化的数据集合。当我们在二叉平衡树中插入或删除一个节点时，只需要通过一系列的旋转操作来调整树的结构，就可以保持树的平衡性，从而保证了整个树的性能。',
            1,0,1,0,0,1,1,0),

            ('在含有n个结点的二叉排序树中查找某关键字的结点时，最多进行（）次比较。',
            'A. n/2',
            'B. log2n',
            'C. log2n+1',
            'D. n',4,
            '在一个含有n个结点的二叉排序树中，最长的路径长度为n，因此，在最坏情况下，需要进行n次比较才能找到目标结点。',
            1,0,0,0,0,0,1,0),

            ('以下关于哈希查找的叙述中错误的是（ ）。',
            'A. 用拉链法解决冲突易引起堆积现象',
            'B. 用线性探测法解决冲突易引起堆积现象',
            'C. 哈希函数选得好可以减少冲突现象',
            'D. 哈希函数H(k)=k MOD p，p通常取小于等于表长的素数',1,
            '当哈希表中存在大量元素时，拉链法的性能可能会急剧下降，因为在遍历链表时需要花费更长的时间来找到匹配的元素。这也会导致哈希表的负载因子变得非常高，这会进一步增加哈希冲突的概率，从而导致更多的堆积现象，最终导致哈希表的性能崩溃',
            1,0,0,0,0,0,0,0),

            ('在平衡二叉树中插入一个结点后造成了不平衡，设最低的不平衡结点为A,并已知A的左孩子的平衡因子为0右孩子的平衡因子为1,则应作( ) 型调整以使其平衡。',
            'A. LL',
            'B. LR',
            'C. RL',
            'D. RR',3,
            '如果使用LL型或RR型调整，将会使得A的左子树或右子树高度更大，而B的高度较小，无法维持平衡。而使用LR型或RL型调整，则可以将A的左右子树高度差不超过1，并且可以保持B的子树结构不变，避免了更多的旋转操作。',
            1,0,0,0,0,0,1,0),

            ('具有12个关键字的有序表，折半查找的平均查找长度（）不是：0.5*成功 + 0.5*失败？',
            'A. 3.1',
            'B. 4',
            'C. 2.5',
            'D. 5',1,
            '折半查找的平均查找长度是根据关键字在有序表中出现的概率分布来计算的。因此，不能简单地将平均查找长度简单地分为成功和失败两个情况。折半查找的平均查找长度为 $log_2(n+1)-1$，其中 $n$ 是有序表中元素的个数。在具有12个关键字的有序表中，$n=12$，因此平均查找长度为 $log_2(13)-1 approx 3.1$。这个公式不考虑查找成功和失败的情况，而是基于有序表中元素的数量来计算平均查找长度。因此，无论查找成功还是失败，平均查找长度都是一样的。',
            1,0,0,0,0,0,0,0),

            ('设哈希表长为14，哈希函数是H(key)=key%11,表中已有数据的关键字地址为：为address(15)=4，address(38)=5，address(61)=6，address(84)=7共四个，现要将关键字为49的结点加到表中，用二次探测再散列法解决冲突，则放入的位置是() ',
            'A. 8',
            'B. 3',
            'C. 5',
            'D. 9',4,
            '根据哈希函数 H(key) = key % 11，可以计算出关键字为 49 的地址为：H(49) = 49 % 11 = 5由于这个地址已经被关键字为 38 的结点占用了，因此需要解决哈希冲突。题目中要求使用二次探测再散列法解决冲突，因此可以使用以下公式来计算下一个探测地址：di = i^2，其中i = 1, 2, 3, ...也就是说，第一次探测地址为 5，第二次探测地址为 6，第三次探测地址为 9，因为：d1 = 1^2 = 1，H(49) + d1 = 5 + 1 = 6d2 = 2^2 = 4，H(49) + d2 = 5 + 4 = 9 因此，关键字为 49 的结点应该插入到地址为 9 的位置上。',
            1,0,1,0,0,1,0,0),

            (' 以下 （ ）方法在数据基本有序时效率最好',
            'A.快速排序',
            'B. 冒泡排序',
            'C. 堆排序',
            'D. 希尔排序',4,
            '当数据基本有序时，希尔排序通过将相距一定间隔的元素分为一组，然后对每组进行插入排序。由于每组元素的距离较远，因此在排序时可以一次移动较多元素的位置，从而加快排序的速度。随着排序的进行，希尔排序会不断缩小元素之间的间隔，直到元素之间的间隔为1，此时就变成了普通的插入排序。在这种情况下，由于元素之间的间隔已经很小了，因此插入排序的效率也会非常高。',
            0,1,1,0,0,0,0,0),

            ('归并排序中，归并的趟数是( )。',
            'A. O（n）',
            'B. O(log₂n)',
            'C. O(nlogn)',
            'D. O(n*n)',2,
            '归并排序的核心思想是将待排序元素分成若干个子序列，然后对每个子序列进行排序，最后再将已排序的子序列合并成一个完整的有序序列。在归并排序的每一轮合并中，都会将相邻的两个子序列合并成一个更大的有序序列。因此，每轮合并都会使序列的长度翻倍。假设序列中有n个元素，每轮合并后序列长度翻倍，那么需要进行log₂n轮合并才能使序列中的所有元素有序。因此，归并排序的归并趟数是log₂n',
            0,1,0,0,0,0,0,0),

            ('下列四个序列中，哪一个是堆（ ）',
            'A. 75,65,30,15,25,45,20,10',
            'B. 75,65,45,10,30,25,20,15',
            'C. 75,45,65,30,15,25,20,10',
            'D. 75,45,65,10,25,30,20,15',2,
            '在这四个序列中，只有选项 B 是堆序列。因为选项 B 中的每个父节点的键值都大于或等于其子节点的键值。例如，节点 75 是其子节点 65 和 45 的父节点，而节点 75 的键值大于其子节点的键值，同样节点 65 和 45 也满足这个条件。因此，选项 B 是堆序列。而在选项 A、C、D 中，存在至少一个父节点的键值小于其子节点的键值，因此它们不是堆序列。',
            0,1,0,0,1,1,0,0),

            ('对序列{15，9，7，8，20，-1，4，} 用希尔排序方法排序，经一趟后序列变为{15，-l，4，8，20，9，7}则该次采用的增量是 ( )',
            'A. 1',
            'B. 4',
            'C. 3',
            'D. 2',2,
            '希尔排序是一种基于插入排序的排序算法，它通过将原始序列分割成若干个子序列来进行排序，逐步缩小子序列的长度，最终将整个序列排序。在希尔排序中，增量序列是关键。增量序列可以是任何数列，但通常使用以下序列：1、4、13、40、121、364、1093、……（也就是h = 3*h + 1，h为当前增量）。其中最后一个增量值必须小于等于序列长度的三分之一。根据题目描述，经过一趟希尔排序后，序列变为 {15，-1，4，8，20，9，7}。因此，我们可以猜测此次采用的增量是4，即按照4-3-1的增量序列进行排序。验证：按照增量为4的希尔排序方法，原序列可以分为两个子序列：{15，20，4，}和{9，-1，7，8}，分别进行插入排序后变为{4，15，20，}和{-1，7，8，9}，然后合并两个子序列得到{4，15，20，-1，7，8，9}，再次进行一趟增量为4的希尔排序后得到{15，-1，4，8，20，9，7}，与题目描述的一致。因此，该次采用的增量为4。',
            0,1,1,0,0,0,0,0),

            (' 一组记录的关键码为（46，79，56，38，40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（ ）',
            'A. (38,40,46,56,79,84）',
            'B. (40,38,46,79,56,84)',
            'C. (40,38,46,56,79,84)',
            'D. (40,38,46,84,56,79)',1,
            '利用快速排序的方法，以第一个记录46为基准进行划分，将比46小的记录放到左边，比46大的记录放到右边，得到以下结果：(38, 40, 56, 46, 79, 84)此时基准记录46已经被放到了不正确的位置上，接下来需要对左右两个子序列分别进行快速排序，直到所有子序列的长度都为1或0。对左边的子序列(38, 40, 56)进行快速排序，以第一个记录38为基准进行划分，得到以下结果：(38, 40, 56)此时左边的子序列已经有序，不需要继续排序。对右边的子序列(79, 84)进行快速排序，以第一个记录79为基准进行划分，得到以下结果：(79, 84)此时右边的子序列已经有序，不需要继续排序。最终得到的排序结果为：(38, 40, 56, 46, 79, 84)',
            0,1,0,0,0,0,0,0),

            ('下列排序方法中，稳定的排序算法是（ ）',
            'A. 希尔排序',
            'B. 快速排序',
            'C. 归并排序',
            'D. 堆排序',3,
            '归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法',
            0,1,1,0,0,0,0,0)




